export const validExpressions = [
    'foo | bar',
    'people[?general.id==`100`] | [0].general',
    'foo[*].bar[*].kind',
    'foo[*].bar[0].kind',
    '@.bar',
    '@.foo[0]',
    "locations[?state == 'WA'].name | sort(@)[-2:] | {WashingtonCities: join(', ', @)}",
    'foo[?!(key||bar)]',
    'sort_by(people, &age)',
    'foo[].not_null(f, e, d, c, b, a)',
    'sort_by(people, &to_number(age_str))',
    'max_by(people, &to_number(age_str))',
    'map(&a, people)',
    'map(&foo.bar, array)',
    'map(&foo.bar.baz, array)',
    'map(&[], array)',
    'sort_by(people, &age)[].extra',
    'not_null(unknown_key, str)',
    'not_null(unknown_key, foo.bar, empty_list, str)',
    'sort_by(people, &age)[].name',
    'sort(keys(objects))',
    "contains(strings, 'a')",
    'length(strings[0])',
    'avg(numbers)',
    'ceil(decimals[2])',
    'abs(array[1])',
    'abs(foo)',
    'sort_by(Contents, &Date)[*].{Key: Key, Size: Size}',
    'foo[*].bar[*] | [0][0]',
    'foo.[baz[*].not_there || baz[*].bar, qux[0]]',
    'foo.[baz[*].bar, qux[0]]',
    'foo.[baz[*].[bar, boo], qux[0]]',
    'foo.[includeme, bar.baz[*].common]',
    'foo.[includeme, bar.baz[*].none]',
    'reservations[*].instances[*].{id: id, name: name}',
    'people[?general.id==`100`].general | [0]',
    'people[?age > `20`].{the_name: name, the_age: age}',
    'people[*].{name: name, tags: tags[0]}',
    'people[?age > `20`].[name, age]',
    'people[?age > `20`].[name]',
    'books.[author.[name,dob,themes], title]',
    'people[*].first',
    '{"x": foo, "y": bar} | [y.baz, x.boo]',
    '{"x": foo, "y": bar} | {"z": y.baz.boo}',
    '{"a": foo.bar, "b": foo.other} | *.baz',
    'foo | other || bar',
    'foo.bam || bar | baz',
    '{"x": foo, "y": bof} | [y.bar]',
    '{"a": foo.bar, "b": foo.baz} | [a.other, b.sub]',
    '{"a": foo.bar, "b": foo.other} | a',
    '{"a": foo.bar, "b": foo.other} | b',
    "instances[].[tags[?Key=='Name'].Values[] | [0]]",
    'foo | bar | baz',
    "reservations[].instances[].[tags[?Key=='Name'].Values[] | [0], type, state.name]",
    'foo.bar[-2]',
    'foo[:20]',
    'foo[0:20]',
    'foo.{"foo.bar": bar}',
    'foo.{bar: bar, baz: baz}',
    'foo.{"bar": bar, "baz": baz}',
    'foo.{bar: bar.baz[1],includeme: includeme}',
    'foo.{"bar.baz.two": bar.baz[1].two, includeme: includeme}',
    'foo.[includeme, bar.baz[].common]',
    'foo.{bar: bar, baz: baz}',
    'foo.[bar,baz]',
    'foo[]',
    'foo.bar[].a',
    'foo.[baz][]',
    'foo[].[baz, qux]',
    'foo[].bar[].[baz, qux][]',
    'foo.[bar[0],baz[3]]',
    'foo.[bar,baz[1]]',
    'foo.[bar,baz[2]]',
    'foo.[bar,baz[3]]',
    'foo[].bar[].[baz, qux]',
    'foo[].bar[].[baz]',
    'reservations[].instances[].{id: id, name: name}',
    'reservations[].instances[].[id, name]',
    'foo',
    'foo[]',
    'foo[].bar',
    'foo[].bar[]',
    'foo.[bar,baz[0]]',
    'foo.{bar:bar,baz:baz}',
    'foo.[bar,qux]',
    'foo.[bar,noexist]',
    'foo.[noexist,alsonoexist]',
    '{bar: bar}',
    '{otherkey: bar}',
    'foo.[bar]',
    'foo.[bar,baz]',
    'foo.nested.three.{a: a, cinner: c.inner}',
    'foo.nested.three.{a: a, c: c.inner.bad.key}',
    'foo.{a: nested.one.a, b: nested.two.b}',
    'foo.badkey.{nokey: nokey, alsonokey: alsonokey}',
    'foo.{bar: bar,qux: qux}',
    'foo.{bar: bar, noexist: noexist}',
    'foo.{noexist: noexist, alsonoexist: alsonoexist}',
    'foo.{bar: bar}',
    'foo.{"bar": bar}',
    'foo.baz | [0]',
    'not_there | [0]',
    '[foo.bar, foo.other, third] | [0]',
    '__L',
    'Y_1623',
    'foo[?bar==`1`].bar[0]',
    'foo[?c == `3` || a == `1` && b == `4`]',
    'foo[?a == `1` && b == `2`]',
    "foo[?name == 'a' || name == 'b']",
    'reservations[].instances[?bar==`1`]',
    'reservations[].instances[?bar==`1`]',
    'reservations[].instances',
    'foo[?key == `null`]',
    'foo[?key == `{"bar": [0]}`]',
    'foo[?age > `25`]',
    'foo[?top.first == top.last]',
    'foo[?top == `{"first": "foo", "last": "bar"}`]',
    'foo[?key == `true`]',
    "foo[?name == 'a']",
    "foo[?top.name == 'a']",
    'foo[?first == last].first',
    'foo[?first == last]',
    "foo[?name == 'a']",
    'True && False',
    'two < one || three < one',
    'one < two',
    'outer.foo || outer.bar',
    'foo\n.\nbar\n.baz',
    'a.b.c.d',
    'a.b.c.d.e.f.g.h',
    'foo[?a==`1`].b.c',
    'reservations[].instances[?bar==`1`][]',
    'reservations[].instances[?bar==`1`]',
    '@.foo[0]'
]

// TODO empty objects, but should they be allowed and replaced by `true` instead?
const notSureIfInvalid = [
    "join('|', decimals[].to_string(@))",
    'foo[?@ == @]',
    'foo[?`5` > @]',
    'sum(array[].to_number(@))'
]
/**
 * JMESPath expressions that are invalid to generate a GraphQL query:
 * - Expressions that results in an empty JSON object
 * - Expressions with invalid GraphQL field names
 * - Or both
 */
export const invalidExpressions = [
    ...notSureIfInvalid,
    'foo.*.bar.baz',
    'foo.nested.*.{a: a,b: b}',
    'foo.*.baz | [1]',
    'foo.*.baz | [0]',
    'foo.bar.* | [0]',
    'foo.* | [0]',
    'people.*.first',
    'foo.*.notbaz | [*]',
    'merge(`{"a": 1}`, `{"b": 2}`)',
    'merge(`{"a": 1, "b": 2}`, `{"a": 2, "c": 3}`, `{"d": 4}`)',
    "contains('abc', 'd')",
    'sort_by(`[]`, &age)',
    'length(@)',
    'ceil(`1.2`)',
    'abs(`-24`)',
    '*[0]',
    '@',
    '*[?[0] == `0`]',
    '[[*],*]',
    '{"baz": baz, "qux\\"": "qux\\""}',
    '"!\\r"',
    '"\\tF\\uCebb"',
    '" \\t"',
    '"foo bar"',
    '"c:\\\\\\\\windows\\\\path"',
    '"\\"\\"\\""'
]

export const expressions = [...invalidExpressions, ...validExpressions]
